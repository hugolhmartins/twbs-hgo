{"version":3,"file":"incremental-dom-cjs.js","sources":["src/util.js","src/node_data.js","src/nodes.js","src/notifications.js","src/context.js","src/assertions.js","src/dom_util.js","src/core.js","src/symbols.js","src/attributes.js","src/virtual_elements.js"],"sourcesContent":["/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A constructor function that will create blank objects.\n * @constructor\n */\nfunction Blank() {}\n\nBlank.prototype = Object.create(null);\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nconst has = function(map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nconst createMap = function() {\n  return new Blank();\n};\n\n\n/** */\nexport {\n  createMap,\n  has\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createMap } from './util';\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {!string} nodeName\n * @param {?string=} key\n * @constructor\n */\nfunction NodeData(nodeName, key) {\n  /**\n   * The attributes and their values.\n   * @const {!Object<string, *>}\n   */\n  this.attrs = createMap();\n\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * The incoming attributes for this Node, before they are updated.\n   * @const {!Object<string, *>}\n   */\n  this.newAttrs = createMap();\n\n  /**\n   * Whether or not the statics have been applied for the node yet.\n   * {boolean}\n   */\n  this.staticsApplied = false;\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @const\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {!Object<string, !Element>}\n   */\n  this.keyMap = createMap();\n\n  /**\n   * Whether or not the keyMap is currently valid.\n   * @type {boolean}\n   */\n  this.keyMapValid = true;\n\n  /**\n   * Whether or the associated node is, or contains, a focused Element.\n   * @type {boolean}\n   */\n  this.focused = false;\n\n  /**\n   * The node name for this node.\n   * @const {string}\n   */\n  this.nodeName = nodeName;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {string} nodeName The node name of node.\n * @param {?string=} key The key that identifies the node.\n * @return {!NodeData} The newly initialized data object\n */\nconst initData = function(node, nodeName, key) {\n  const data = new NodeData(nodeName, key);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {?Node} node The Node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nconst getData = function(node) {\n  importNode(node);\n  return node['__incrementalDOMData'];\n};\n\n\n/**\n * Imports node and its subtree, initializing caches.\n *\n * @param {?Node} node The Node to import.\n */\nconst importNode = function(node) {\n  if (node['__incrementalDOMData']) {\n    return;\n  }\n\n  const isElement = node instanceof Element;\n  const nodeName = isElement ? node.localName : node.nodeName;\n  const key = isElement ? node.getAttribute('key') : null;\n  const data = initData(node, nodeName, key);\n\n  if (key) {\n    getData(node.parentNode).keyMap[key] = node;\n  }\n\n  if (isElement) {\n    const attributes = node.attributes;\n    const attrs = data.attrs;\n    const newAttrs = data.newAttrs;\n    const attrsArr = data.attrsArr;\n\n    for (let i = 0; i < attributes.length; i += 1) {\n      const attr = attributes[i];\n      const name = attr.name;\n      const value = attr.value;\n\n      attrs[name] = value;\n      newAttrs[name] = undefined;\n      attrsArr.push(name);\n      attrsArr.push(value);\n    }\n  }\n\n  for (let child = node.firstChild; child; child = child.nextSibling) {\n    importNode(child);\n  }\n};\n\n\n/** */\nexport {\n  getData,\n  initData,\n  importNode\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n    getData,\n    initData\n} from './node_data';\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nconst getNamespaceForTag = function(tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nodeName === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {string} tag The tag for the Element.\n * @param {?string=} key A key to identify the Element.\n * @return {!Element}\n */\nconst createElement = function(doc, parent, tag, key) {\n  const namespace = getNamespaceForTag(tag, parent);\n  let el;\n\n  if (namespace) {\n    el = doc.createElementNS(namespace, tag);\n  } else {\n    el = doc.createElement(tag);\n  }\n\n  initData(el, tag, key);\n\n  return el;\n};\n\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nconst createText = function(doc) {\n  const node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n\n/** */\nexport {\n  createElement,\n  createText\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nconst notifications = {\n  /**\n   * Called after patch has compleated with any Nodes that have been created\n   * and added to the DOM.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesCreated: null,\n\n  /**\n   * Called after patch has compleated with any Nodes that have been removed\n   * from the DOM.\n   * Note it's an applications responsibility to handle any childNodes.\n   * @type {?function(Array<!Node>)}\n   */\n  nodesDeleted: null\n};\n\nexport {\n  notifications\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { notifications } from './notifications';\n\n\n/**\n * Keeps track of the state of a patch.\n * @constructor\n */\nfunction Context() {\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.created = notifications.nodesCreated && [];\n\n  /**\n   * @type {(Array<!Node>|undefined)}\n   */\n  this.deleted = notifications.nodesDeleted && [];\n}\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markCreated = function(node) {\n  if (this.created) {\n    this.created.push(node);\n  }\n};\n\n\n/**\n * @param {!Node} node\n */\nContext.prototype.markDeleted = function(node) {\n  if (this.deleted) {\n    this.deleted.push(node);\n  }\n};\n\n\n/**\n * Notifies about nodes that were created during the patch opearation.\n */\nContext.prototype.notifyChanges = function() {\n  if (this.created && this.created.length > 0) {\n    notifications.nodesCreated(this.created);\n  }\n\n  if (this.deleted && this.deleted.length > 0) {\n    notifications.nodesDeleted(this.deleted);\n  }\n};\n\n\n/** */\nexport {\n  Context\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n  * Keeps track whether or not we are in an attributes declaration (after\n  * elementOpenStart, but before elementOpenEnd).\n  * @type {boolean}\n  */\nlet inAttributes = false;\n\n\n/**\n  * Keeps track whether or not we are in an element that should not have its\n  * children cleared.\n  * @type {boolean}\n  */\nlet inSkip = false;\n\n\n/**\n * Makes sure that there is a current patch context.\n * @param {string} functionName\n * @param {*} context\n */\nconst assertInPatch = function(functionName, context) {\n  if (!context) {\n    throw new Error('Cannot call ' + functionName + '() unless in patch.');\n  }\n};\n\n\n/**\n * Makes sure that a patch closes every node that it opened.\n * @param {?Node} openElement\n * @param {!Node|!DocumentFragment} root\n */\nconst assertNoUnclosedTags = function(openElement, root) {\n  if (openElement === root) {\n    return;\n  }\n\n  let currentElement = openElement;\n  const openTags = [];\n  while (currentElement && currentElement !== root) {\n    openTags.push(currentElement.nodeName.toLowerCase());\n    currentElement = currentElement.parentNode;\n  }\n\n  throw new Error('One or more tags were not closed:\\n' +\n      openTags.join('\\n'));\n};\n\n\n/**\n * Makes sure that the caller is not where attributes are expected.\n * @param {string} functionName\n */\nconst assertNotInAttributes = function(functionName) {\n  if (inAttributes) {\n    throw new Error(functionName + '() can not be called between ' +\n        'elementOpenStart() and elementOpenEnd().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is not inside an element that has declared skip.\n * @param {string} functionName\n */\nconst assertNotInSkip = function(functionName) {\n  if (inSkip) {\n    throw new Error(functionName + '() may not be called inside an element ' +\n        'that has called skip().');\n  }\n};\n\n\n/**\n * Makes sure that the caller is where attributes are expected.\n * @param {string} functionName\n */\nconst assertInAttributes = function(functionName) {\n  if (!inAttributes) {\n    throw new Error(functionName + '() can only be called after calling ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n * Makes sure the patch closes virtual attributes call\n */\nconst assertVirtualAttributesClosed = function() {\n  if (inAttributes) {\n    throw new Error('elementOpenEnd() must be called after calling ' +\n        'elementOpenStart().');\n  }\n};\n\n\n/**\n  * Makes sure that tags are correctly nested.\n  * @param {string} nodeName\n  * @param {string} tag\n  */\nconst assertCloseMatchesOpenTag = function(nodeName, tag) {\n  if (nodeName !== tag) {\n    throw new Error('Received a call to close \"' + tag + '\" but \"' +\n        nodeName + '\" was open.');\n  }\n};\n\n\n/**\n * Makes sure that no children elements have been declared yet in the current\n * element.\n * @param {string} functionName\n * @param {?Node} previousNode\n */\nconst assertNoChildrenDeclaredYet = function(functionName, previousNode) {\n  if (previousNode !== null) {\n    throw new Error(functionName + '() must come before any child ' +\n        'declarations inside the current element.');\n  }\n};\n\n\n/**\n * Checks that a call to patchOuter actually patched the element.\n * @param {?Node} startNode The value for the currentNode when the patch\n *     started.\n * @param {?Node} currentNode The currentNode when the patch finished.\n * @param {?Node} expectedNextNode The Node that is expected to follow the\n *    currentNode after the patch;\n * @param {?Node} expectedPrevNode The Node that is expected to preceed the\n *    currentNode after the patch.\n */\nconst assertPatchElementNoExtras = function(\n    startNode,\n    currentNode,\n    expectedNextNode,\n    expectedPrevNode) {\n  const wasUpdated = currentNode.nextSibling === expectedNextNode &&\n                     currentNode.previousSibling === expectedPrevNode;\n  const wasChanged = currentNode.nextSibling === startNode.nextSibling &&\n                     currentNode.previousSibling === expectedPrevNode;\n  const wasRemoved = currentNode === startNode;\n\n  if (!wasUpdated && !wasChanged && !wasRemoved) {\n    throw new Error('There must be exactly one top level call corresponding ' +\n        'to the patched element.');\n  }\n};\n\n\n/**\n * Updates the state of being in an attribute declaration.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nconst setInAttributes = function(value) {\n  const previous = inAttributes;\n  inAttributes = value;\n  return previous;\n};\n\n\n/**\n * Updates the state of being in a skip element.\n * @param {boolean} value\n * @return {boolean} the previous value.\n */\nconst setInSkip = function(value) {\n  const previous = inSkip;\n  inSkip = value;\n  return previous;\n};\n\n\n/** */\nexport {\n  assertInPatch,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertInAttributes,\n  assertCloseMatchesOpenTag,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertNotInSkip,\n  assertPatchElementNoExtras,\n  setInAttributes,\n  setInSkip\n};\n","/**\n * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * @param {!Node} node\n * @return {boolean} True if the node the root of a document, false otherwise.\n */\nconst isDocumentRoot = function(node) {\n  // For ShadowRoots, check if they are a DocumentFragment instead of if they\n  // are a ShadowRoot so that this can work in 'use strict' if ShadowRoots are\n  // not supported.\n  return node instanceof Document || node instanceof DocumentFragment;\n};\n\n\n/**\n * @param {!Node} node The node to start at, inclusive.\n * @param {?Node} root The root ancestor to get until, exclusive.\n * @return {!Array<!Node>} The ancestry of DOM nodes.\n */\nconst getAncestry = function(node, root) {\n  const ancestry = [];\n  let cur = node;\n\n  while (cur !== root) {\n    ancestry.push(cur);\n    cur = cur.parentNode;\n  }\n\n  return ancestry;\n};\n\n\n/**\n * @param {!Node} node\n * @return {!Node} The root node of the DOM tree that contains node.\n */\nconst getRoot = function(node) {\n  let cur = node;\n  let prev = cur;\n\n  while (cur) {\n    prev = cur;\n    cur = cur.parentNode;\n  }\n\n  return prev;\n};\n\n\n/**\n * @param {!Node} node The node to get the activeElement for.\n * @return {?Element} The activeElement in the Document or ShadowRoot\n *     corresponding to node, if present.\n */\nconst getActiveElement = function(node) {\n  const root = getRoot(node);\n  return isDocumentRoot(root) ? root.activeElement : null;\n};\n\n\n/**\n * Gets the path of nodes that contain the focused node in the same document as\n * a reference node, up until the root.\n * @param {!Node} node The reference node to get the activeElement for.\n * @param {?Node} root The root to get the focused path until.\n * @return {!Array<Node>}\n */\nconst getFocusedPath = function(node, root) {\n  const activeElement = getActiveElement(node);\n\n  if (!activeElement || !node.contains(activeElement)) {\n    return [];\n  }\n\n  return getAncestry(activeElement, root);\n};\n\n\n/**\n * Like insertBefore, but instead instead of moving the desired node, instead\n * moves all the other nodes after.\n * @param {?Node} parentNode\n * @param {!Node} node\n * @param {?Node} referenceNode\n */\nconst moveBefore = function(parentNode, node, referenceNode) {\n  const insertReferenceNode = node.nextSibling;\n  let cur = referenceNode;\n\n  while (cur !== node) {\n    const next = cur.nextSibling;\n    parentNode.insertBefore(cur, insertReferenceNode);\n    cur = next;\n  }\n};\n\n\n/** */\nexport {\n  getFocusedPath,\n  moveBefore\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  createElement,\n  createText\n} from './nodes';\nimport { getData } from './node_data';\nimport { Context } from './context';\nimport {\n  assertInPatch,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertPatchElementNoExtras,\n  setInAttributes,\n  setInSkip\n} from './assertions';\nimport {\n  getFocusedPath,\n  moveBefore\n} from './dom_util';\n\n\n/** @type {?Context} */\nlet context = null;\n\n/** @type {?Node} */\nlet currentNode = null;\n\n/** @type {?Node} */\nlet currentParent = null;\n\n/** @type {?Document} */\nlet doc = null;\n\n\n/**\n * @param {!Array<Node>} focusPath The nodes to mark.\n * @param {boolean} focused Whether or not they are focused.\n */\nconst markFocused = function(focusPath, focused) {\n  for (let i = 0; i < focusPath.length; i += 1) {\n    getData(focusPath[i]).focused = focused;\n  }\n};\n\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=): ?Node} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=): ?Node}\n * @template T\n */\nconst patchFactory = function(run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @return {?Node} node\n   * @template T\n   */\n  const f = function(node, fn, data) {\n    const prevContext = context;\n    const prevDoc = doc;\n    const prevCurrentNode = currentNode;\n    const prevCurrentParent = currentParent;\n    let previousInAttributes = false;\n    let previousInSkip = false;\n\n    context = new Context();\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if (process.env.NODE_ENV !== 'production') {\n      previousInAttributes = setInAttributes(false);\n      previousInSkip = setInSkip(false);\n    }\n\n    const focusPath = getFocusedPath(node, currentParent);\n    markFocused(focusPath, true);\n    const retVal = run(node, fn, data);\n    markFocused(focusPath, false);\n\n    if (process.env.NODE_ENV !== 'production') {\n      assertVirtualAttributesClosed();\n      setInAttributes(previousInAttributes);\n      setInSkip(previousInSkip);\n    }\n\n    context.notifyChanges();\n\n    context = prevContext;\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n\n    return retVal;\n  };\n  return f;\n};\n\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Document\n *     to patch.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {!Node} The patched node.\n * @template T\n */\nconst patchInner = patchFactory(function(node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoUnclosedTags(currentNode, node);\n  }\n\n  return node;\n});\n\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing elementOpen/elementClose/etc.\n *     calls that describe the DOM. This should have at most one top level\n *     element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {?Node} The node if it was updated, its replacedment or null if it\n *     was removed.\n * @template T\n */\nconst patchOuter = patchFactory(function(node, fn, data) {\n  let startNode = /** @type {!Element} */({ nextSibling: node });\n  let expectedNextNode = null;\n  let expectedPrevNode = null;\n\n  if (process.env.NODE_ENV !== 'production') {\n    expectedNextNode = node.nextSibling;\n    expectedPrevNode = node.previousSibling;\n  }\n\n  currentNode = startNode;\n  fn(data);\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertPatchElementNoExtras(startNode, currentNode, expectedNextNode,\n        expectedPrevNode);\n  }\n\n  if (node !== currentNode && node.parentNode) {\n    removeChild(currentParent, node, getData(currentParent).keyMap);\n  }\n\n  return (startNode === currentNode) ? null : currentNode;\n});\n\n\n/**\n * Checks whether or not the current node matches the specified nodeName and\n * key.\n *\n * @param {!Node} matchNode A node to match the data to.\n * @param {?string} nodeName The nodeName for this node.\n * @param {?string=} key An optional key that identifies a node.\n * @return {boolean} True if the node matches, false otherwise.\n */\nconst matches = function(matchNode, nodeName, key) {\n  const data = getData(matchNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nodeName === data.nodeName && key == data.key;\n};\n\n\n/**\n * Aligns the virtual Element definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {string} nodeName For an Element, this should be a valid tag string.\n *     For a Text, this should be #text.\n * @param {?string=} key The key used to identify this element.\n */\nconst alignWithDOM = function(nodeName, key) {\n  if (currentNode && matches(currentNode, nodeName, key)) {\n    return;\n  }\n\n  const parentData = getData(currentParent);\n  const currentNodeData = currentNode && getData(currentNode);\n  const keyMap = parentData.keyMap;\n  let node;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    const keyNode = keyMap[key];\n    if (keyNode) {\n      if (matches(keyNode, nodeName, key)) {\n        node = keyNode;\n      } else if (keyNode === currentNode) {\n        context.markDeleted(keyNode);\n      } else {\n        removeChild(currentParent, keyNode, keyMap);\n      }\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nodeName === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nodeName, key);\n    }\n\n    if (key) {\n      keyMap[key] = node;\n    }\n\n    context.markCreated(node);\n  }\n\n  // Re-order the node into the right position, preserving focus if either\n  // node or currentNode are focused by making sure that they are not detached\n  // from the DOM.\n  if (getData(node).focused) {\n    // Move everything else before the node.\n    moveBefore(currentParent, node, currentNode);\n  } else if (currentNodeData && currentNodeData.key && !currentNodeData.focused) {\n    // Remove the currentNode, which can always be added back since we hold a\n    // reference through the keyMap. This prevents a large number of moves when\n    // a keyed item is removed or moved backwards in the DOM.\n    currentParent.replaceChild(node, currentNode);\n    parentData.keyMapValid = false;\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n\n/**\n * @param {?Node} node\n * @param {?Node} child\n * @param {?Object<string, !Element>} keyMap\n */\nconst removeChild = function(node, child, keyMap) {\n  node.removeChild(child);\n  context.markDeleted(/** @type {!Node}*/(child));\n\n  const key = getData(child).key;\n  if (key) {\n    delete keyMap[key];\n  }\n};\n\n\n/**\n * Clears out any unvisited Nodes, as the corresponding virtual element\n * functions were never called for them.\n */\nconst clearUnvisitedDOM = function() {\n  const node = currentParent;\n  const data = getData(node);\n  const keyMap = data.keyMap;\n  const keyMapValid = data.keyMapValid;\n  let child = node.lastChild;\n  let key;\n\n  if (child === currentNode && keyMapValid) {\n    return;\n  }\n\n  while (child !== currentNode) {\n    removeChild(node, child, keyMap);\n    child = node.lastChild;\n  }\n\n  // Clean the keyMap, removing any unusued keys.\n  if (!keyMapValid) {\n    for (key in keyMap) {\n      child = keyMap[key];\n      if (child.parentNode !== node) {\n        context.markDeleted(child);\n        delete keyMap[key];\n      }\n    }\n\n    data.keyMapValid = true;\n  }\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nconst enterNode = function() {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n\n/**\n * @return {?Node} The next Node to be patched.\n */\nconst getNextNode = function() {\n  if (currentNode) {\n    return currentNode.nextSibling;\n  } else {\n    return currentParent.firstChild;\n  }\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nconst nextNode = function() {\n  currentNode = getNextNode();\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nconst exitNode = function() {\n  clearUnvisitedDOM();\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n\n/**\n * Makes sure that the current node is an Element with a matching tagName and\n * key.\n *\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpen = function(tag, key) {\n  nextNode();\n  alignWithDOM(tag, key);\n  enterNode();\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nconst elementClose = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return /** @type {!Element} */(currentNode);\n};\n\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nconst text = function() {\n  nextNode();\n  alignWithDOM('#text', null);\n  return /** @type {!Text} */(currentNode);\n};\n\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nconst currentElement = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch('currentElement', context);\n    assertNotInAttributes('currentElement');\n  }\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * @return {Node} The Node that will be evaluated for the next instruction.\n */\nconst currentPointer = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInPatch('currentPointer', context);\n    assertNotInAttributes('currentPointer');\n  }\n  return getNextNode();\n};\n\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nconst skip = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNoChildrenDeclaredYet('skip', currentNode);\n    setInSkip(true);\n  }\n  currentNode = currentParent.lastChild;\n};\n\n\n/**\n * Skips the next Node to be patched, moving the pointer forward to the next\n * sibling of the current pointer.\n */\nconst skipNode = nextNode;\n\n\n/** */\nexport {\n  elementOpen,\n  elementClose,\n  text,\n  patchInner,\n  patchOuter,\n  currentElement,\n  currentPointer,\n  skip,\n  skipNode\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nconst symbols = {\n  default: '__default'\n};\n\n/** */\nexport {\n  symbols\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getData } from './node_data';\nimport { symbols } from './symbols';\nimport {\n  createMap,\n  has\n} from './util';\n\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nconst getNamespace = function(name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nconst applyAttr = function(el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    const attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nconst applyProp = function(el, name, value) {\n  el[name] = value;\n};\n\n\n/**\n * Applies a value to a style declaration. Supports CSS custom properties by\n * setting properties containing a dash using CSSStyleDeclaration.setProperty.\n * @param {CSSStyleDeclaration} style\n * @param {!string} prop\n * @param {*} value\n */\nconst setStyleValue = function(style, prop, value) {\n  if (prop.indexOf('-') >= 0) {\n    style.setProperty(prop, /** @type {string} */(value));\n  } else {\n    style[prop] = value;\n  }\n};\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nconst applyStyle = function(el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    const elStyle = el.style;\n    const obj = /** @type {!Object<string,string>} */(style);\n\n    for (const prop in obj) {\n      if (has(obj, prop)) {\n        setStyleValue(elStyle, prop, obj[prop]);\n      }\n    }\n  }\n};\n\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nconst applyAttributeTyped = function(el, name, value) {\n  const type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n  }\n};\n\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nconst updateAttribute = function(el, name, value) {\n  const data = getData(el);\n  const attrs = data.attrs;\n\n  if (attrs[name] === value) {\n    return;\n  }\n\n  const mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n\n  attrs[name] = value;\n};\n\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nconst attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes['style'] = applyStyle;\n\n\n/** */\nexport {\n  updateAttribute,\n  applyProp,\n  applyAttr,\n  attributes\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  elementOpen as coreElementOpen,\n  elementClose as coreElementClose,\n  text as coreText\n} from './core';\nimport { updateAttribute } from './attributes';\nimport { getData } from './node_data';\nimport {\n  assertNotInAttributes,\n  assertNotInSkip,\n  assertInAttributes,\n  assertCloseMatchesOpenTag,\n  setInAttributes\n} from './assertions';\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nconst ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {Array<*>}\n */\nconst argsBuilder = [];\n\n\n/**\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpen = function(tag, key, statics, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  const node = coreElementOpen(tag, key);\n  const data = getData(node);\n\n  if (!data.staticsApplied) {\n    if (statics) {\n      for (let i = 0; i < statics.length; i += 2) {\n        const name = /** @type {string} */(statics[i]);\n        const value = statics[i + 1];\n        updateAttribute(node, name, value);\n      }\n    }\n    // Down the road, we may want to keep track of the statics array to use it\n    // as an additional signal about whether a node matches or not. For now,\n    // just use a marker so that we do not reapply statics.\n    data.staticsApplied = true;\n  }\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  const attrsArr = data.attrsArr;\n  const newAttrs = data.newAttrs;\n  const isNew = !attrsArr.length;\n  let i = ATTRIBUTES_OFFSET;\n  let j = 0;\n\n  for (; i < arguments.length; i += 2, j += 2) {\n    const attr = arguments[i];\n    if (isNew) {\n      attrsArr[j] = attr;\n      newAttrs[attr] = undefined;\n    } else if (attrsArr[j] !== attr) {\n      break;\n    }\n\n    const value = arguments[i + 1];\n    if (isNew || attrsArr[j + 1] !== value) {\n      attrsArr[j + 1] = value;\n      updateAttribute(node, attr, value);\n    }\n  }\n\n  if (i < arguments.length || j < attrsArr.length) {\n    for (; i < arguments.length; i += 1, j += 1) {\n      attrsArr[j] = arguments[i];\n    }\n\n    if (j < attrsArr.length) {\n      attrsArr.length = j;\n    }\n\n    /*\n     * Actually perform the attribute update.\n     */\n    for (i = 0; i < attrsArr.length; i += 2) {\n      const name = /** @type {string} */(attrsArr[i]);\n      const value = attrsArr[i + 1];\n      newAttrs[name] = value;\n    }\n\n    for (const attr in newAttrs) {\n      updateAttribute(node, attr, newAttrs[attr]);\n      newAttrs[attr] = undefined;\n    }\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nconst elementOpenStart = function(tag, key, statics) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = tag;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nconst attr = function(name, value) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name);\n  argsBuilder.push(value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpenEnd = function() {\n  if (process.env.NODE_ENV !== 'production') {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  const node = elementOpen.apply(null, argsBuilder);\n  argsBuilder.length = 0;\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {string} tag The element's tag.\n * @return {!Element} The corresponding Element.\n */\nconst elementClose = function(tag) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('elementClose');\n  }\n\n  const node = coreElementClose();\n\n  if (process.env.NODE_ENV !== 'production') {\n    assertCloseMatchesOpenTag(getData(node).nodeName, tag);\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {string} tag The element's tag.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementVoid = function(tag, key, statics, var_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(tag);\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nconst text = function(value, var_args) {\n  if (process.env.NODE_ENV !== 'production') {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  const node = coreText();\n  const data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */(value);\n\n    let formatted = value;\n    for (let i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      const fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\n\n/** */\nexport {\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementVoid,\n  elementClose,\n  text,\n  attr\n};\n"],"names":["elementOpen","elementClose","text"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA,IAAM,iBAAiB,OAAO,SAAP,CAAiB,cAAjB;;;;;;AAOvB,SAAS,KAAT,GAAiB,EAAjB;;AAEA,MAAM,SAAN,GAAkB,OAAO,MAAP,CAAc,IAAd,CAAlB;;;;;;;;AASA,IAAM,MAAM,UAAS,GAAT,EAAc,QAAd,EAAwB;SAC3B,eAAe,IAAf,CAAoB,GAApB,EAAyB,QAAzB,CAAP,CADkC;CAAxB;;;;;;AASZ,IAAM,YAAY,YAAW;SACpB,IAAI,KAAJ,EAAP,CAD2B;CAAX;;;;;;;;ACtBlB,SAAS,QAAT,CAAkB,QAAlB,EAA4B,GAA5B,EAAiC;;;;;OAK1B,KAAL,GAAa,WAAb;;;;;;;;MAQA,CAAK,QAAL,GAAgB,EAAhB;;;;;;MAMA,CAAK,QAAL,GAAgB,WAAhB;;;;;;MAMA,CAAK,cAAL,GAAsB,KAAtB;;;;;;;MAOA,CAAK,GAAL,GAAW,GAAX;;;;;;MAMA,CAAK,MAAL,GAAc,WAAd;;;;;;MAMA,CAAK,WAAL,GAAmB,IAAnB;;;;;;MAMA,CAAK,OAAL,GAAe,KAAf;;;;;;MAMA,CAAK,QAAL,GAAgB,QAAhB;;;;;MAKA,CAAK,IAAL,GAAY,IAAZ,CA7D+B;CAAjC;;;;;;;;;;AAyEA,IAAM,WAAW,UAAS,IAAT,EAAe,QAAf,EAAyB,GAAzB,EAA8B;MACvC,OAAO,IAAI,QAAJ,CAAa,QAAb,EAAuB,GAAvB,CAAP,CADuC;OAExC,sBAAL,IAA+B,IAA/B,CAF6C;SAGtC,IAAP,CAH6C;CAA9B;;;;;;;;AAajB,IAAM,UAAU,UAAS,IAAT,EAAe;aAClB,IAAX,EAD6B;SAEtB,KAAK,sBAAL,CAAP,CAF6B;CAAf;;;;;;;AAWhB,IAAM,aAAa,UAAS,IAAT,EAAe;MAC5B,KAAK,sBAAL,CAAJ,EAAkC;WAAA;GAAlC;;MAIM,YAAY,gBAAgB,OAAhB,CALc;MAM1B,WAAW,YAAY,KAAK,SAAL,GAAiB,KAAK,QAAL,CANd;MAO1B,MAAM,YAAY,KAAK,YAAL,CAAkB,KAAlB,CAAZ,GAAuC,IAAvC,CAPoB;MAQ1B,OAAO,SAAS,IAAT,EAAe,QAAf,EAAyB,GAAzB,CAAP,CAR0B;;MAU5B,GAAJ,EAAS;YACC,KAAK,UAAL,CAAR,CAAyB,MAAzB,CAAgC,GAAhC,IAAuC,IAAvC,CADO;GAAT;;MAII,SAAJ,EAAe;QACP,aAAa,KAAK,UAAL,CADN;QAEP,QAAQ,KAAK,KAAL,CAFD;QAGP,WAAW,KAAK,QAAL,CAHJ;QAIP,WAAW,KAAK,QAAL,CAJJ;;SAMR,IAAI,IAAI,CAAJ,EAAO,IAAI,WAAW,MAAX,EAAmB,KAAK,CAAL,EAAQ;UACvC,OAAO,WAAW,CAAX,CAAP,CADuC;UAEvC,OAAO,KAAK,IAAL,CAFgC;UAGvC,QAAQ,KAAK,KAAL,CAH+B;;YAKvC,IAAN,IAAc,KAAd,CAL6C;eAMpC,IAAT,IAAiB,SAAjB,CAN6C;eAOpC,IAAT,CAAc,IAAd,EAP6C;eAQpC,IAAT,CAAc,KAAd,EAR6C;KAA/C;GANF;;OAkBK,IAAI,QAAQ,KAAK,UAAL,EAAiB,KAAlC,EAAyC,QAAQ,MAAM,WAAN,EAAmB;eACvD,KAAX,EADkE;GAApE;CAhCiB;;;;;;;;AC9FnB,IAAM,qBAAqB,UAAS,GAAT,EAAc,MAAd,EAAsB;MAC3C,QAAQ,KAAR,EAAe;WACV,4BAAP,CADiB;GAAnB;;MAII,QAAQ,MAAR,EAAgB,QAAhB,KAA6B,eAA7B,EAA8C;WACzC,IAAP,CADgD;GAAlD;;SAIO,OAAO,YAAP,CATwC;CAAtB;;;;;;;;;;AAqB3B,IAAM,gBAAgB,UAAS,GAAT,EAAc,MAAd,EAAsB,GAAtB,EAA2B,GAA3B,EAAgC;MAC9C,YAAY,mBAAmB,GAAnB,EAAwB,MAAxB,CAAZ,CAD8C;MAEhD,cAAJ,CAFoD;;MAIhD,SAAJ,EAAe;SACR,IAAI,eAAJ,CAAoB,SAApB,EAA+B,GAA/B,CAAL,CADa;GAAf,MAEO;SACA,IAAI,aAAJ,CAAkB,GAAlB,CAAL,CADK;GAFP;;WAMS,EAAT,EAAa,GAAb,EAAkB,GAAlB,EAVoD;;SAY7C,EAAP,CAZoD;CAAhC;;;;;;;AAqBtB,IAAM,aAAa,UAAS,GAAT,EAAc;MACzB,OAAO,IAAI,cAAJ,CAAmB,EAAnB,CAAP,CADyB;WAEtB,IAAT,EAAe,OAAf,EAAwB,IAAxB,EAF+B;SAGxB,IAAP,CAH+B;CAAd;;;;;;;;;;;;;;;;;;;ACrDnB,IAAM,gBAAgB;;;;;;gBAMN,IAAd;;;;;;;;gBAQc,IAAd;CAdI;;;;;;ACMN,SAAS,OAAT,GAAmB;;;;OAIZ,OAAL,GAAe,cAAc,YAAd,IAA8B,EAA9B;;;;;MAKf,CAAK,OAAL,GAAe,cAAc,YAAd,IAA8B,EAA9B,CATE;CAAnB;;;;;AAgBA,QAAQ,SAAR,CAAkB,WAAlB,GAAgC,UAAS,IAAT,EAAe;MACzC,KAAK,OAAL,EAAc;SACX,OAAL,CAAa,IAAb,CAAkB,IAAlB,EADgB;GAAlB;CAD8B;;;;;AAUhC,QAAQ,SAAR,CAAkB,WAAlB,GAAgC,UAAS,IAAT,EAAe;MACzC,KAAK,OAAL,EAAc;SACX,OAAL,CAAa,IAAb,CAAkB,IAAlB,EADgB;GAAlB;CAD8B;;;;;AAUhC,QAAQ,SAAR,CAAkB,aAAlB,GAAkC,YAAW;MACvC,KAAK,OAAL,IAAgB,KAAK,OAAL,CAAa,MAAb,GAAsB,CAAtB,EAAyB;kBAC7B,YAAd,CAA2B,KAAK,OAAL,CAA3B,CAD2C;GAA7C;;MAII,KAAK,OAAL,IAAgB,KAAK,OAAL,CAAa,MAAb,GAAsB,CAAtB,EAAyB;kBAC7B,YAAd,CAA2B,KAAK,OAAL,CAA3B,CAD2C;GAA7C;CALgC;;;;;;;;;;;;;;;;;;;;;;;ACrClC,IAAI,eAAe,KAAf;;;;;;;AAQJ,IAAI,SAAS,KAAT;;;;;;;AAQJ,IAAM,gBAAgB,UAAS,YAAT,EAAuB,OAAvB,EAAgC;MAChD,CAAC,OAAD,EAAU;UACN,IAAI,KAAJ,CAAU,iBAAiB,YAAjB,GAAgC,qBAAhC,CAAhB,CADY;GAAd;CADoB;;;;;;;AAYtB,IAAM,uBAAuB,UAAS,WAAT,EAAsB,IAAtB,EAA4B;MACnD,gBAAgB,IAAhB,EAAsB;WAAA;GAA1B;;MAII,iBAAiB,WAAjB,CALmD;MAMjD,WAAW,EAAX,CANiD;SAOhD,kBAAkB,mBAAmB,IAAnB,EAAyB;aACvC,IAAT,CAAc,eAAe,QAAf,CAAwB,WAAxB,EAAd,EADgD;qBAE/B,eAAe,UAAf,CAF+B;GAAlD;;QAKM,IAAI,KAAJ,CAAU,wCACZ,SAAS,IAAT,CAAc,IAAd,CADY,CAAhB,CAZuD;CAA5B;;;;;;AAqB7B,IAAM,wBAAwB,UAAS,YAAT,EAAuB;MAC/C,YAAJ,EAAkB;UACV,IAAI,KAAJ,CAAU,eAAe,+BAAf,GACZ,0CADY,CAAhB,CADgB;GAAlB;CAD4B;;;;;;AAY9B,IAAM,kBAAkB,UAAS,YAAT,EAAuB;MACzC,MAAJ,EAAY;UACJ,IAAI,KAAJ,CAAU,eAAe,yCAAf,GACZ,yBADY,CAAhB,CADU;GAAZ;CADsB;;;;;;AAYxB,IAAM,qBAAqB,UAAS,YAAT,EAAuB;MAC5C,CAAC,YAAD,EAAe;UACX,IAAI,KAAJ,CAAU,eAAe,sCAAf,GACZ,qBADY,CAAhB,CADiB;GAAnB;CADyB;;;;;AAW3B,IAAM,gCAAgC,YAAW;MAC3C,YAAJ,EAAkB;UACV,IAAI,KAAJ,CAAU,mDACZ,qBADY,CAAhB,CADgB;GAAlB;CADoC;;;;;;;AAatC,IAAM,4BAA4B,UAAS,QAAT,EAAmB,GAAnB,EAAwB;MACpD,aAAa,GAAb,EAAkB;UACd,IAAI,KAAJ,CAAU,+BAA+B,GAA/B,GAAqC,SAArC,GACZ,QADY,GACD,aADC,CAAhB,CADoB;GAAtB;CADgC;;;;;;;;AAclC,IAAM,8BAA8B,UAAS,YAAT,EAAuB,YAAvB,EAAqC;MACnE,iBAAiB,IAAjB,EAAuB;UACnB,IAAI,KAAJ,CAAU,eAAe,gCAAf,GACZ,0CADY,CAAhB,CADyB;GAA3B;CADkC;;;;;;;;;;;;AAkBpC,IAAM,6BAA6B,UAC/B,SAD+B,EAE/B,WAF+B,EAG/B,gBAH+B,EAI/B,gBAJ+B,EAIb;MACd,aAAa,YAAY,WAAZ,KAA4B,gBAA5B,IACA,YAAY,eAAZ,KAAgC,gBAAhC,CAFC;MAGd,aAAa,YAAY,WAAZ,KAA4B,UAAU,WAAV,IAC5B,YAAY,eAAZ,KAAgC,gBAAhC,CAJC;MAKd,aAAa,gBAAgB,SAAhB,CALC;;MAOhB,CAAC,UAAD,IAAe,CAAC,UAAD,IAAe,CAAC,UAAD,EAAa;UACvC,IAAI,KAAJ,CAAU,4DACZ,yBADY,CAAhB,CAD6C;GAA/C;CAXiC;;;;;;;AAuBnC,IAAM,kBAAkB,UAAS,KAAT,EAAgB;MAChC,WAAW,YAAX,CADgC;iBAEvB,KAAf,CAFsC;SAG/B,QAAP,CAHsC;CAAhB;;;;;;;AAYxB,IAAM,YAAY,UAAS,KAAT,EAAgB;MAC1B,WAAW,MAAX,CAD0B;WAEvB,KAAT,CAFgC;SAGzB,QAAP,CAHgC;CAAhB;;;;;;;;;;;;;;;;;;;;;;ACrKlB,IAAM,iBAAiB,UAAS,IAAT,EAAe;;;;SAI7B,gBAAgB,QAAhB,IAA4B,gBAAgB,gBAAhB,CAJC;CAAf;;;;;;;AAavB,IAAM,cAAc,UAAS,IAAT,EAAe,IAAf,EAAqB;MACjC,WAAW,EAAX,CADiC;MAEnC,MAAM,IAAN,CAFmC;;SAIhC,QAAQ,IAAR,EAAc;aACV,IAAT,CAAc,GAAd,EADmB;UAEb,IAAI,UAAJ,CAFa;GAArB;;SAKO,QAAP,CATuC;CAArB;;;;;;AAiBpB,IAAM,UAAU,UAAS,IAAT,EAAe;MACzB,MAAM,IAAN,CADyB;MAEzB,OAAO,GAAP,CAFyB;;SAItB,GAAP,EAAY;WACH,GAAP,CADU;UAEJ,IAAI,UAAJ,CAFI;GAAZ;;SAKO,IAAP,CAT6B;CAAf;;;;;;;AAkBhB,IAAM,mBAAmB,UAAS,IAAT,EAAe;MAChC,OAAO,QAAQ,IAAR,CAAP,CADgC;SAE/B,eAAe,IAAf,IAAuB,KAAK,aAAL,GAAqB,IAA5C,CAF+B;CAAf;;;;;;;;;AAazB,IAAM,iBAAiB,UAAS,IAAT,EAAe,IAAf,EAAqB;MACpC,gBAAgB,iBAAiB,IAAjB,CAAhB,CADoC;;MAGtC,CAAC,aAAD,IAAkB,CAAC,KAAK,QAAL,CAAc,aAAd,CAAD,EAA+B;WAC5C,EAAP,CADmD;GAArD;;SAIO,YAAY,aAAZ,EAA2B,IAA3B,CAAP,CAP0C;CAArB;;;;;;;;;AAkBvB,IAAM,aAAa,UAAS,UAAT,EAAqB,IAArB,EAA2B,aAA3B,EAA0C;MACrD,sBAAsB,KAAK,WAAL,CAD+B;MAEvD,MAAM,aAAN,CAFuD;;SAIpD,QAAQ,IAAR,EAAc;QACb,OAAO,IAAI,WAAJ,CADM;eAER,YAAX,CAAwB,GAAxB,EAA6B,mBAA7B,EAFmB;UAGb,IAAN,CAHmB;GAArB;CAJiB;;;AC7DnB,IAAI,UAAU,IAAV;;;AAGJ,IAAI,cAAc,IAAd;;;AAGJ,IAAI,gBAAgB,IAAhB;;;AAGJ,IAAI,MAAM,IAAN;;;;;;AAOJ,IAAM,cAAc,UAAS,SAAT,EAAoB,OAApB,EAA6B;OAC1C,IAAI,IAAI,CAAJ,EAAO,IAAI,UAAU,MAAV,EAAkB,KAAK,CAAL,EAAQ;YACpC,UAAU,CAAV,CAAR,EAAsB,OAAtB,GAAgC,OAAhC,CAD4C;GAA9C;CADkB;;;;;;;;;AAcpB,IAAM,eAAe,UAAS,GAAT,EAAc;;;;;;;;;;;MAW3B,IAAI,UAAS,IAAT,EAAe,EAAf,EAAmB,IAAnB,EAAyB;QAC3B,cAAc,OAAd,CAD2B;QAE3B,UAAU,GAAV,CAF2B;QAG3B,kBAAkB,WAAlB,CAH2B;QAI3B,oBAAoB,aAApB,CAJ2B;QAK7B,uBAAuB,KAAvB,CAL6B;QAM7B,iBAAiB,KAAjB,CAN6B;;cAQvB,IAAI,OAAJ,EAAV,CARiC;UAS3B,KAAK,aAAL,CAT2B;oBAUjB,KAAK,UAAL,CAViB;;QAY7B,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;6BAClB,gBAAgB,KAAhB,CAAvB,CADyC;uBAExB,UAAU,KAAV,CAAjB,CAFyC;KAA3C;;QAKM,YAAY,eAAe,IAAf,EAAqB,aAArB,CAAZ,CAjB2B;gBAkBrB,SAAZ,EAAuB,IAAvB,EAlBiC;QAmB3B,SAAS,IAAI,IAAJ,EAAU,EAAV,EAAc,IAAd,CAAT,CAnB2B;gBAoBrB,SAAZ,EAAuB,KAAvB,EApBiC;;QAsB7B,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;sCAAA;sBAEzB,oBAAhB,EAFyC;gBAG/B,cAAV,EAHyC;KAA3C;;YAMQ,aAAR,GA5BiC;;cA8BvB,WAAV,CA9BiC;UA+B3B,OAAN,CA/BiC;kBAgCnB,eAAd,CAhCiC;oBAiCjB,iBAAhB,CAjCiC;;WAmC1B,MAAP,CAnCiC;GAAzB,CAXuB;SAgD1B,CAAP,CAhDiC;CAAd;;;;;;;;;;;;;AA+DrB,IAAM,aAAa,aAAa,UAAS,IAAT,EAAe,EAAf,EAAmB,IAAnB,EAAyB;gBACzC,IAAd,CADuD;;cAAA;KAIpD,IAAH,EAJuD;aAAA;;MAOnD,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;yBACpB,WAArB,EAAkC,IAAlC,EADyC;GAA3C;;SAIO,IAAP,CAXuD;CAAzB,CAA1B;;;;;;;;;;;;;;AA2BN,IAAM,aAAa,aAAa,UAAS,IAAT,EAAe,EAAf,EAAmB,IAAnB,EAAyB;MACnD,mCAAoC,EAAE,aAAa,IAAb,EAAtC,CADmD;MAEnD,mBAAmB,IAAnB,CAFmD;MAGnD,mBAAmB,IAAnB,CAHmD;;MAKnD,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;uBACtB,KAAK,WAAL,CADsB;uBAEtB,KAAK,eAAL,CAFsB;GAA3C;;gBAKc,SAAd,CAVuD;KAWpD,IAAH,EAXuD;;MAanD,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;+BACd,SAA3B,EAAsC,WAAtC,EAAmD,gBAAnD,EACI,gBADJ,EADyC;GAA3C;;MAKI,SAAS,WAAT,IAAwB,KAAK,UAAL,EAAiB;gBAC/B,aAAZ,EAA2B,IAA3B,EAAiC,QAAQ,aAAR,EAAuB,MAAvB,CAAjC,CAD2C;GAA7C;;SAIO,SAAC,KAAc,WAAd,GAA6B,IAA9B,GAAqC,WAArC,CAtBgD;CAAzB,CAA1B;;;;;;;;;;;AAmCN,IAAM,UAAU,UAAS,SAAT,EAAoB,QAApB,EAA8B,GAA9B,EAAmC;MAC3C,OAAO,QAAQ,SAAR,CAAP;;;;;SAKC,aAAa,KAAK,QAAL,IAAiB,OAAO,KAAK,GAAL,CANK;CAAnC;;;;;;;;;AAiBhB,IAAM,eAAe,UAAS,QAAT,EAAmB,GAAnB,EAAwB;MACvC,eAAe,QAAQ,WAAR,EAAqB,QAArB,EAA+B,GAA/B,CAAf,EAAoD;WAAA;GAAxD;;MAIM,aAAa,QAAQ,aAAR,CAAb,CALqC;MAMrC,kBAAkB,eAAe,QAAQ,WAAR,CAAf,CANmB;MAOrC,SAAS,WAAW,MAAX,CAP4B;MAQvC,gBAAJ;;;MAGI,GAAJ,EAAS;QACD,UAAU,OAAO,GAAP,CAAV,CADC;QAEH,OAAJ,EAAa;UACP,QAAQ,OAAR,EAAiB,QAAjB,EAA2B,GAA3B,CAAJ,EAAqC;eAC5B,OAAP,CADmC;OAArC,MAEO,IAAI,YAAY,WAAZ,EAAyB;gBAC1B,WAAR,CAAoB,OAApB,EADkC;OAA7B,MAEA;oBACO,aAAZ,EAA2B,OAA3B,EAAoC,MAApC,EADK;OAFA;KAHT;GAFF;;;MAcI,CAAC,IAAD,EAAO;QACL,aAAa,OAAb,EAAsB;aACjB,WAAW,GAAX,CAAP,CADwB;KAA1B,MAEO;aACE,cAAc,GAAd,EAAmB,aAAnB,EAAkC,QAAlC,EAA4C,GAA5C,CAAP,CADK;KAFP;;QAMI,GAAJ,EAAS;aACA,GAAP,IAAc,IAAd,CADO;KAAT;;YAIQ,WAAR,CAAoB,IAApB,EAXS;GAAX;;;;;MAiBI,QAAQ,IAAR,EAAc,OAAd,EAAuB;;eAEd,aAAX,EAA0B,IAA1B,EAAgC,WAAhC,EAFyB;GAA3B,MAGO,IAAI,mBAAmB,gBAAgB,GAAhB,IAAuB,CAAC,gBAAgB,OAAhB,EAAyB;;;;kBAI/D,YAAd,CAA2B,IAA3B,EAAiC,WAAjC,EAJ6E;eAKlE,WAAX,GAAyB,KAAzB,CAL6E;GAAxE,MAMA;kBACS,YAAd,CAA2B,IAA3B,EAAiC,WAAjC,EADK;GANA;;gBAUO,IAAd,CAvD2C;CAAxB;;;;;;;AAgErB,IAAM,cAAc,UAAS,IAAT,EAAe,KAAf,EAAsB,MAAtB,EAA8B;OAC3C,WAAL,CAAiB,KAAjB,EADgD;UAExC,WAAR,qBAAwC,KAAxC,EAFgD;;MAI1C,MAAM,QAAQ,KAAR,EAAe,GAAf,CAJoC;MAK5C,GAAJ,EAAS;WACA,OAAO,GAAP,CAAP,CADO;GAAT;CALkB;;;;;;AAepB,IAAM,oBAAoB,YAAW;MAC7B,OAAO,aAAP,CAD6B;MAE7B,OAAO,QAAQ,IAAR,CAAP,CAF6B;MAG7B,SAAS,KAAK,MAAL,CAHoB;MAI7B,cAAc,KAAK,WAAL,CAJe;MAK/B,QAAQ,KAAK,SAAL,CALuB;MAM/B,eAAJ,CANmC;;MAQ/B,UAAU,WAAV,IAAyB,WAAzB,EAAsC;WAAA;GAA1C;;SAIO,UAAU,WAAV,EAAuB;gBAChB,IAAZ,EAAkB,KAAlB,EAAyB,MAAzB,EAD4B;YAEpB,KAAK,SAAL,CAFoB;GAA9B;;;MAMI,CAAC,WAAD,EAAc;SACX,GAAL,IAAY,MAAZ,EAAoB;cACV,OAAO,GAAP,CAAR,CADkB;UAEd,MAAM,UAAN,KAAqB,IAArB,EAA2B;gBACrB,WAAR,CAAoB,KAApB,EAD6B;eAEtB,OAAO,GAAP,CAAP,CAF6B;OAA/B;KAFF;;SAQK,WAAL,GAAmB,IAAnB,CATgB;GAAlB;CAlBwB;;;;;AAmC1B,IAAM,YAAY,YAAW;kBACX,WAAhB,CAD2B;gBAEb,IAAd,CAF2B;CAAX;;;;;AASlB,IAAM,cAAc,YAAW;MACzB,WAAJ,EAAiB;WACR,YAAY,WAAZ,CADQ;GAAjB,MAEO;WACE,cAAc,UAAd,CADF;GAFP;CADkB;;;;;AAYpB,IAAM,WAAW,YAAW;gBACZ,aAAd,CAD0B;CAAX;;;;;AAQjB,IAAM,WAAW,YAAW;sBAAA;;gBAGZ,aAAd,CAH0B;kBAIV,cAAc,UAAd,CAJU;CAAX;;;;;;;;;;;;AAkBjB,IAAMA,kBAAc,UAAS,GAAT,EAAc,GAAd,EAAmB;aAAA;eAExB,GAAb,EAAkB,GAAlB,EAFqC;cAAA;iCAIN,aAA/B;IAJqC;CAAnB;;;;;;;;AAcpB,IAAMC,mBAAe,YAAW;MAC1B,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;cAC/B,KAAV,EADyC;GAA3C;;aAD8B;iCAMC,WAA/B;IAN8B;CAAX;;;;;;;;AAgBrB,IAAMC,WAAO,YAAW;aAAA;eAET,OAAb,EAAsB,IAAtB,EAFsB;8BAGM,WAA5B;IAHsB;CAAX;;;;;;AAWb,IAAM,iBAAiB,YAAW;MAC5B,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;kBAC3B,gBAAd,EAAgC,OAAhC,EADyC;0BAEnB,gBAAtB,EAFyC;GAA3C;iCAI+B,aAA/B;IALgC;CAAX;;;;;AAYvB,IAAM,iBAAiB,YAAW;MAC5B,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;kBAC3B,gBAAd,EAAgC,OAAhC,EADyC;0BAEnB,gBAAtB,EAFyC;GAA3C;SAIO,aAAP,CALgC;CAAX;;;;;;AAavB,IAAM,OAAO,YAAW;MAClB,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;gCACb,MAA5B,EAAoC,WAApC,EADyC;cAE/B,IAAV,EAFyC;GAA3C;gBAIc,cAAc,SAAd,CALQ;CAAX;;;;;;AAab,IAAM,WAAW,QAAX;;;;;;;;;;;;;;;;;;;AClbN,IAAM,UAAU;WACL,WAAT;CADI;;;;;;ACWN,IAAM,eAAe,UAAS,IAAT,EAAe;MAC9B,KAAK,WAAL,CAAiB,MAAjB,EAAyB,CAAzB,MAAgC,CAAhC,EAAmC;WAC9B,sCAAP,CADqC;GAAvC;;MAII,KAAK,WAAL,CAAiB,QAAjB,EAA2B,CAA3B,MAAkC,CAAlC,EAAqC;WAChC,8BAAP,CADuC;GAAzC;CALmB;;;;;;;;;;AAmBrB,IAAM,YAAY,UAAS,EAAT,EAAa,IAAb,EAAmB,KAAnB,EAA0B;MACtC,SAAS,IAAT,EAAe;OACd,eAAH,CAAmB,IAAnB,EADiB;GAAnB,MAEO;QACC,SAAS,aAAa,IAAb,CAAT,CADD;QAED,MAAJ,EAAY;SACP,cAAH,CAAkB,MAAlB,EAA0B,IAA1B,EAAgC,KAAhC,EADU;KAAZ,MAEO;SACF,YAAH,CAAgB,IAAhB,EAAsB,KAAtB,EADK;KAFP;GAJF;CADgB;;;;;;;;AAmBlB,IAAM,YAAY,UAAS,EAAT,EAAa,IAAb,EAAmB,KAAnB,EAA0B;KACvC,IAAH,IAAW,KAAX,CAD0C;CAA1B;;;;;;;;;AAYlB,IAAM,gBAAgB,UAAS,KAAT,EAAgB,IAAhB,EAAsB,KAAtB,EAA6B;MAC7C,KAAK,OAAL,CAAa,GAAb,KAAqB,CAArB,EAAwB;UACpB,WAAN,CAAkB,IAAlB,uBAA8C,KAA9C,EAD0B;GAA5B,MAEO;UACC,IAAN,IAAc,KAAd,CADK;GAFP;CADoB;;;;;;;;;;AAiBtB,IAAM,aAAa,UAAS,EAAT,EAAa,IAAb,EAAmB,KAAnB,EAA0B;MACvC,OAAO,KAAP,KAAiB,QAAjB,EAA2B;OAC1B,KAAH,CAAS,OAAT,GAAmB,KAAnB,CAD6B;GAA/B,MAEO;OACF,KAAH,CAAS,OAAT,GAAmB,EAAnB,CADK;QAEC,UAAU,GAAG,KAAH,CAFX;QAGC,2CAA4C,KAA5C,CAHD;;SAKA,IAAM,IAAN,IAAc,GAAnB,EAAwB;UAClB,IAAI,GAAJ,EAAS,IAAT,CAAJ,EAAoB;sBACJ,OAAd,EAAuB,IAAvB,EAA6B,IAAI,IAAJ,CAA7B,EADkB;OAApB;KADF;GAPF;CADiB;;;;;;;;;;AAyBnB,IAAM,sBAAsB,UAAS,EAAT,EAAa,IAAb,EAAmB,KAAnB,EAA0B;MAC9C,OAAO,OAAO,KAAP,CADuC;;MAGhD,SAAS,QAAT,IAAqB,SAAS,UAAT,EAAqB;cAClC,EAAV,EAAc,IAAd,EAAoB,KAApB,EAD4C;GAA9C,MAEO;cACK,EAAV,EAAc,IAAd,yCAA4D,KAA5D,EADK;GAFP;CAH0B;;;;;;;;AAiB5B,IAAM,kBAAkB,UAAS,EAAT,EAAa,IAAb,EAAmB,KAAnB,EAA0B;MAC1C,OAAO,QAAQ,EAAR,CAAP,CAD0C;MAE1C,QAAQ,KAAK,KAAL,CAFkC;;MAI5C,MAAM,IAAN,MAAgB,KAAhB,EAAuB;WAAA;GAA3B;;MAIM,UAAU,WAAW,IAAX,KAAoB,WAAW,QAAQ,OAAR,CAA/B,CARgC;UASxC,EAAR,EAAY,IAAZ,EAAkB,KAAlB,EATgD;;QAW1C,IAAN,IAAc,KAAd,CAXgD;CAA1B;;;;;;AAmBxB,IAAM,aAAa,WAAb;;;;AAIN,WAAW,QAAQ,OAAR,CAAX,GAA8B,mBAA9B;;AAEA,WAAW,OAAX,IAAsB,UAAtB;;;;;;;AC7HA,IAAM,oBAAoB,CAApB;;;;;;;AAQN,IAAM,cAAc,EAAd;;;;;;;;;;;;;;AAeN,IAAM,cAAc,UAAS,GAAT,EAAc,GAAd,EAAmB,OAAnB,EAA4B,QAA5B,EAAsC;MACpD,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;0BACnB,aAAtB,EADyC;oBAEzB,aAAhB,EAFyC;GAA3C;;MAKM,OAAO,gBAAgB,GAAhB,EAAqB,GAArB,CAAP,CANkD;MAOlD,OAAO,QAAQ,IAAR,CAAP,CAPkD;;MASpD,CAAC,KAAK,cAAL,EAAqB;QACpB,OAAJ,EAAa;WACN,IAAI,KAAI,CAAJ,EAAO,KAAI,QAAQ,MAAR,EAAgB,MAAK,CAAL,EAAQ;YACpC,4BAA6B,QAAQ,EAAR,CAA7B,CADoC;YAEpC,QAAQ,QAAQ,KAAI,CAAJ,CAAhB,CAFoC;wBAG1B,IAAhB,EAAsB,IAAtB,EAA4B,KAA5B,EAH0C;OAA5C;KADF;;;;QAUA,CAAK,cAAL,GAAsB,IAAtB,CAXwB;GAA1B;;;;;;;;MAoBM,WAAW,KAAK,QAAL,CA7BuC;MA8BlD,WAAW,KAAK,QAAL,CA9BuC;MA+BlD,QAAQ,CAAC,SAAS,MAAT,CA/ByC;MAgCpD,IAAI,iBAAJ,CAhCoD;MAiCpD,IAAI,CAAJ,CAjCoD;;SAmCjD,IAAI,UAAU,MAAV,EAAkB,KAAK,CAAL,EAAQ,KAAK,CAAL,EAAQ;QACrC,QAAO,UAAU,CAAV,CAAP,CADqC;QAEvC,KAAJ,EAAW;eACA,CAAT,IAAc,KAAd,CADS;eAEA,KAAT,IAAiB,SAAjB,CAFS;KAAX,MAGO,IAAI,SAAS,CAAT,MAAgB,KAAhB,EAAsB;YAAA;KAA1B;;QAID,QAAQ,UAAU,IAAI,CAAJ,CAAlB,CATqC;QAUvC,SAAS,SAAS,IAAI,CAAJ,CAAT,KAAoB,KAApB,EAA2B;eAC7B,IAAI,CAAJ,CAAT,GAAkB,KAAlB,CADsC;sBAEtB,IAAhB,EAAsB,KAAtB,EAA4B,KAA5B,EAFsC;KAAxC;GAVF;;MAgBI,IAAI,UAAU,MAAV,IAAoB,IAAI,SAAS,MAAT,EAAiB;WACxC,IAAI,UAAU,MAAV,EAAkB,KAAK,CAAL,EAAQ,KAAK,CAAL,EAAQ;eAClC,CAAT,IAAc,UAAU,CAAV,CAAd,CAD2C;KAA7C;;QAII,IAAI,SAAS,MAAT,EAAiB;eACd,MAAT,GAAkB,CAAlB,CADuB;KAAzB;;;;;SAOK,IAAI,CAAJ,EAAO,IAAI,SAAS,MAAT,EAAiB,KAAK,CAAL,EAAQ;UACjC,4BAA6B,SAAS,CAAT,CAA7B,CADiC;UAEjC,QAAQ,SAAS,IAAI,CAAJ,CAAjB,CAFiC;eAG9B,IAAT,IAAiB,KAAjB,CAHuC;KAAzC;;SAMK,IAAM,MAAN,IAAc,QAAnB,EAA6B;sBACX,IAAhB,EAAsB,MAAtB,EAA4B,SAAS,MAAT,CAA5B,EAD2B;eAElB,MAAT,IAAiB,SAAjB,CAF2B;KAA7B;GAlBF;;SAwBO,IAAP,CA3EwD;CAAtC;;;;;;;;;;;;;;;;AA6FpB,IAAM,mBAAmB,UAAS,GAAT,EAAc,GAAd,EAAmB,OAAnB,EAA4B;MAC/C,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;0BACnB,kBAAtB,EADyC;oBAEzB,IAAhB,EAFyC;GAA3C;;cAKY,CAAZ,IAAiB,GAAjB,CANmD;cAOvC,CAAZ,IAAiB,GAAjB,CAPmD;cAQvC,CAAZ,IAAiB,OAAjB,CARmD;CAA5B;;;;;;;;;AAmBzB,IAAM,OAAO,UAAS,IAAT,EAAe,KAAf,EAAsB;MAC7B,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;uBACtB,MAAnB,EADyC;GAA3C;;cAIY,IAAZ,CAAiB,IAAjB,EALiC;cAMrB,IAAZ,CAAiB,KAAjB,EANiC;CAAtB;;;;;;AAcb,IAAM,iBAAiB,YAAW;MAC5B,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;uBACtB,gBAAnB,EADyC;oBAEzB,KAAhB,EAFyC;GAA3C;;MAKM,OAAO,YAAY,KAAZ,CAAkB,IAAlB,EAAwB,WAAxB,CAAP,CAN0B;cAOpB,MAAZ,GAAqB,CAArB,CAPgC;SAQzB,IAAP,CARgC;CAAX;;;;;;;;AAkBvB,IAAM,eAAe,UAAS,GAAT,EAAc;MAC7B,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;0BACnB,cAAtB,EADyC;GAA3C;;MAIM,OAAO,kBAAP,CAL2B;;MAO7B,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;8BACf,QAAQ,IAAR,EAAc,QAAd,EAAwB,GAAlD,EADyC;GAA3C;;SAIO,IAAP,CAXiC;CAAd;;;;;;;;;;;;;;;;AA6BrB,IAAM,cAAc,UAAS,GAAT,EAAc,GAAd,EAAmB,OAAnB,EAA4B,QAA5B,EAAsC;cAC5C,KAAZ,CAAkB,IAAlB,EAAwB,SAAxB,EADwD;SAEjD,aAAa,GAAb,CAAP,CAFwD;CAAtC;;;;;;;;;;;AAepB,IAAM,OAAO,UAAS,KAAT,EAAgB,QAAhB,EAA0B;MACjC,QAAQ,GAAR,CAAY,QAAZ,KAAyB,YAAzB,EAAuC;0BACnB,MAAtB,EADyC;oBAEzB,MAAhB,EAFyC;GAA3C;;MAKM,OAAO,UAAP,CAN+B;MAO/B,OAAO,QAAQ,IAAR,CAAP,CAP+B;;MASjC,KAAK,IAAL,KAAc,KAAd,EAAqB;SAClB,IAAL,wBAAkC,KAAlC,CADuB;;QAGnB,YAAY,KAAZ,CAHmB;SAIlB,IAAI,IAAI,CAAJ,EAAO,IAAI,UAAU,MAAV,EAAkB,KAAK,CAAL,EAAQ;;;;;UAKtC,KAAK,UAAU,CAAV,CAAL,CALsC;kBAMhC,GAAG,SAAH,CAAZ,CAN4C;KAA9C;;SASK,IAAL,GAAY,SAAZ,CAbuB;GAAzB;;SAgBO,IAAP,CAzBqC;CAA1B;;;;;;;;;;;;;;;;;;;;;","sourceRoot":"/source/"}